Анализ кода на соответствие .NET/C# Coding Conventions:

Именование

✅ Класс Abs назван кратко и отражает операцию.

✅ Пространство имён Fungus соответствует проекту.

❗️ Поля inValue и outValue нарушают конвенцию: для public членов нужно PascalCase. Исправьте на InValue и OutValue.

Структура класса

✅ Корректное наследование от BaseUnaryMathCommand.

✅ Модификатор public у класса корректен.

Документация

✅ Присутствует XML-комментарий для класса.

❗️ Можно добавить пример использования:

csharp
/// <example>
/// <code>
/// inValue = -5.3f;
/// outValue = 0f;
/// // Результат: outValue = 5.3f
/// </code>
/// </example>
Метод OnEnter()

✅ Правильное переопределение через override.

❗️ Добавьте проверку на null:

csharp
if (inValue == null || outValue == null)
{
    Debug.LogError("Null values detected");
    return;
}
✅ Вызов Continue() в конце корректен.

Безопасность типов

❗️ Mathf.Abs работает с float. Если требуется поддержка int, добавьте:

csharp
outValue.Value = Mathf.Abs(inValue.Value);

// Альтернатива для int:
if (inValue.Value is int intVal)
{
    outValue.Value = Math.Abs(intVal);
}
Атрибуты

✅ [CommandInfo] корректно настроен.

✅ [AddComponentMenu("")] скрывает компонент из меню – ок, если преднамеренно.

Форматирование

✅ Правильные отступы и пробелы.

✅ Логическое разделение операций.

Рекомендации:

Переименуйте поля в PascalCase

Добавьте проверки на null

Уточните документацию примером

Реализуйте поддержку int (если требуется)

Исправленный код:

csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Command to execute and store the result of a Abs
    /// </summary>
    /// <example>
    /// <code>
    /// inValue = -5.3f;
    /// outValue = 0f;
    /// // Результат: outValue = 5.3f
    /// </code>
    /// </example>
    [CommandInfo("Math",
                 "Abs",
                 "Command to execute and store the result of a Abs")]
    [AddComponentMenu("")]
    public class Abs : BaseUnaryMathCommand
    {
        public override void OnEnter()
        {
            if (InValue == null || OutValue == null)
            {
                Debug.LogError("Null values detected in Abs command");
                return;
            }

            if (InValue.Value is int intVal)
            {
                OutValue.Value = Math.Abs(intVal);
            }
            else
            {
                OutValue.Value = Mathf.Abs(InValue.Value);
            }

            Continue();
        }
    }
}
1. Именование
✅ Класс AnimatorProperty – название отражает функционал.

❗ Поля animatorVar, inOutVar – нарушают конвенцию: для protected полей используется camelCase без подчеркивания.
Исправление:

csharp
[SerializeField]
protected AnimatorVariable _animatorVar;
❗ Локальные переменные iob, iof – сокращения ухудшают читаемость.
Исправление:

csharp
var boolVar = inOutVar as BooleanVariable;
var floatVar = inOutVar as FloatVariable;
2. Структура кода
✅ Наследование от BaseVariableProperty корректно.

❗ Метод OnEnter() – отсутствуют проверки на null перед использованием animatorVar.Value.
Добавить:

csharp
if (_animatorVar == null || inOutVar == null || _animatorVar.Value == null)
{
    Debug.LogError("Animator or variable not set!");
    Continue();
    return;
}
3. Документация
❗ XML-комментарий класса – опечатка в начале: // <summary> → /// <summary>.

❗ Не хватает примеров и описания параметров.
Добавить:

csharp
/// <example>
/// <code>
/// // Установка скорости аниматора
/// animatorVar = myAnimator;
/// inOutVar = speedFloat;
/// property = Property.Speed;
/// getOrSet = GetSet.Set;
/// </code>
/// </example>
4. Безопасность типов
❗ Приведение типов as BooleanVariable – нет обработки случаев, когда inOutVar не соответствует типу.
Добавить проверку:

csharp
if (boolVar == null)
{
    Debug.LogError("Variable is not a BooleanVariable");
    return;
}
5. Форматирование
❗ Несоответствие отступов в блоке #if UNITY_2019_2_OR_NEWER.
Исправление:

csharp
#if UNITY_2019_2_OR_NEWER
case Property.KeepAnimatorControllerStateOnDisable:
    target.keepAnimatorStateOnDisable = boolVar.Value;
    break;
#endif
6. Обработка ошибок
❗ Дефолтные case в switch – логирование без прерывания выполнения.
Исправление:

csharp
default:
    Debug.LogError($"Unsupported property: {property}");
    break;
7. Прочие замечания
✅ Атрибуты [CommandInfo] и [VariableProperty] корректны.

✅ Метод GetSummary() – правильно возвращает информацию о состоянии.

Исправленный код (ключевые фрагменты):

csharp
/// <summary>
/// Get or Set a property of a Animator component
/// </summary>
/// <example>
/// <code>
/// // Установка скорости аниматора
/// animatorVar = myAnimator;
/// inOutVar = speedFloat;
/// property = Property.Speed;
/// getOrSet = GetSet.Set;
/// </code>
/// </example>
[CommandInfo("Property", 
             "Animator",
             "Get or Set a property of a Animator component")]
[AddComponentMenu("")]
public class AnimatorProperty : BaseVariableProperty
{
    [SerializeField]
    protected AnimatorVariable _animatorVar;

    public override void OnEnter()
    {
        if (_animatorVar == null || inOutVar == null || _animatorVar.Value == null)
        {
            Debug.LogError("Animator or variable not set!");
            Continue();
            return;
        }

        var boolVar = inOutVar as BooleanVariable;
        if (boolVar == null && property == Property.IsOptimizable /*...*/)
        {
            Debug.LogError("Type mismatch for variable");
            return;
        }

        // ... остальной код ...
    }
}
Рекомендации:

Переименовать поля в camelCase с подчеркиванием.

Добавить проверки на null и тип переменных.

Исправить документацию и форматирование.

Улучшить обработку неподдерживаемых операций.

1. Именование
✅ Класс AssertCommand – название соответствует PascalCase и отражает функционал.

❗ Поля a, b, message – нарушение конвенции: публичные/сериализуемые поля должны использовать PascalCase.
Исправление:

csharp
[SerializeField] 
protected Variable _a, _b;

[SerializeField]
protected StringData _message;
2. Документация
❗ Неполный XML-комментарий класса.
Добавить:

csharp
/// <example>
/// <code>
/// // Проверка равенства переменных Health и MaxHealth
/// a = Health;
/// b = MaxHealth;
/// method = AreEqual;
/// </code>
/// </example>
3. Безопасность
❗ Отсутствует проверка на null перед вызовом a.GetValue().
Добавить:

csharp
if (_a == null || _b == null)
{
    Debug.LogError("Variables not assigned!");
    Continue();
    return;
}
❗ Нет проверки типов переменных. Сравнение разных типов (например, string и int) вызовет ошибку.
Решение:

csharp
if (_a.GetType() != _b.GetType())
{
    Debug.LogError($"Type mismatch: {_a.GetType()} vs {_b.GetType()}");
    return;
}
4. Обработка ошибок
❗ Пустой default case в switch.
Исправление:

csharp
default:
    Debug.LogError($"Unsupported method: {method}");
    break;
5. Оптимизация кода
✅ Метод HasReference корректен, но можно упростить:

csharp
public override bool HasReference(Variable variable)
    => variable == _message.stringRef || 
       variable == _a || 
       variable == _b || 
       base.HasReference(variable);
6. Прочие замечания
✅ Атрибуты [CommandInfo] и [VariableProperty] настроены правильно.

✅ Логика сравнения через Assert соответствует заявленной цели.

Исправленный код:

csharp
using UnityEngine;
using UnityEngine.Assertions;

namespace Fungus
{
    /// <summary>
    /// Assert on 2 Fungus variable values.
    /// </summary>
    /// <example>
    /// <code>
    /// // Проверка равенства переменных Health и MaxHealth
    /// a = Health;
    /// b = MaxHealth;
    /// method = AreEqual;
    /// </code>
    /// </example>
    [CommandInfo("Scripting",
                 "Assert",
                 "Assert based on compared values.")]
    [AddComponentMenu("")]
    public class AssertCommand : Command
    {
        [SerializeField]
        protected StringData _message;

        [SerializeField]
        [VariableProperty(AllVariableTypes.VariableAny.Any)]
        protected Variable _a, _b;

        public enum Method { AreEqual, AreNotEqual }

        [SerializeField]
        protected Method _method;

        public override void OnEnter()
        {
            if (_a == null || _b == null)
            {
                Debug.LogError("Assert variables not set!");
                Continue();
                return;
            }

            if (_a.GetType() != _b.GetType())
            {
                Debug.LogError($"Type mismatch: {_a.GetType()} vs {_b.GetType()}");
                Continue();
                return;
            }

            switch (_method)
            {
                case Method.AreEqual:
                    Assert.AreEqual(_a.GetValue(), _b.GetValue(), _message.Value);
                    break;

                case Method.AreNotEqual:
                    Assert.AreNotEqual(_a.GetValue(), _b.GetValue(), _message.Value);
                    break;

                default:
                    Debug.LogError($"Unsupported method: {_method}");
                    break;
            }

            Continue();
        }

        public override string GetSummary()
        {
            if (_a == null) return "Error: No A variable";
            if (_b == null) return "Error: No B variable";
            return $"{_a.Key} {_method} {_b.Key}";
        }

        public override bool HasReference(Variable variable)
            => variable == _message.stringRef || 
               variable == _a || 
               variable == _b || 
               base.HasReference(variable);
    }
}
Основные улучшения:

Переименованы поля в camelCase с подчеркиванием.

Добавлены проверки на null и совпадение типов.

Улучшена обработка ошибок в switch.

Добавлен XML-пример использования.

В сообщения Assert добавлен текст из _message.
1. Именование
✅ Класс AudioSourceProperty - соответствует конвенции PascalCase.

❗ Поля audioSourceVar, inOutVar - нарушают конвенцию именования protected полей (должны быть camelCase с _).
Исправление:

csharp
[SerializeField]
protected AudioSourceVariable _audioSourceVar;

[SerializeField]
protected Variable _inOutVar;
❗ Локальные переменные iof, ioi, iob - неинформативные сокращения.
Исправление:

csharp
var floatVar = _inOutVar as FloatVariable;
var intVar = _inOutVar as IntegerVariable;
var boolVar = _inOutVar as BooleanVariable;
2. Документация
❗ Неполный XML-комментарий (не хватает примеров).
Добавить:

csharp
/// <example>
/// <code>
/// // Установка громкости аудио
/// audioSourceVar = MyAudioSource;
/// inOutVar = VolumeFloat;
/// property = Property.Volume;
/// getOrSet = GetSet.Set;
/// </code>
/// </example>
3. Безопасность
❗ Отсутствуют проверки на null перед использованием Value.
Добавить:

csharp
if (_audioSourceVar == null || _inOutVar == null || _audioSourceVar.Value == null)
{
    Debug.LogError("AudioSource or variable not assigned!");
    Continue();
    return;
}
❗ Нет проверки типов при приведении переменных.
Добавить:

csharp
if ((property требует FloatVariable && floatVar == null) ||
    (property требует BooleanVariable && boolVar == null))
{
    Debug.LogError($"Type mismatch for property {property}");
    return;
}
4. Обработка ошибок
❗ Дефолтные case только логируют ошибку без остановки.
Улучшить:

csharp
default:
    Debug.LogError($"Unsupported property: {property}");
    break;
5. Оптимизация
✅ Метод HasReference корректен, но можно упростить:

csharp
public override bool HasReference(Variable variable) 
    => _audioSourceVar == variable || 
       _inOutVar == variable || 
       base.HasReference(variable);
6. Прочие замечания
✅ Атрибуты [CommandInfo] и [VariableProperty] корректны.

❗ Метод GetSummary() можно улучшить:

csharp
public override string GetSummary()
{
    if (_audioSourceVar == null) return "Error: No AudioSource";
    if (_inOutVar == null) return "Error: No output variable";
    return $"{getOrSet} {property}";
}
Исправленный код (ключевые части):
csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Get or Set a property of a AudioSource component
    /// </summary>
    /// <example>
    /// <code>
    /// // Установка громкости аудио
    /// audioSourceVar = MyAudioSource;
    /// inOutVar = VolumeFloat;
    /// property = Property.Volume;
    /// getOrSet = GetSet.Set;
    /// </code>
    /// </example>
    [CommandInfo("Property",
                 "AudioSource",
                 "Get or Set a property of a AudioSource component")]
    [AddComponentMenu("")]
    public class AudioSourceProperty : BaseVariableProperty
    {
        public enum Property 
        { 
            Volume, Pitch, /*...*/ 
        }

        [SerializeField]
        protected AudioSourceVariable _audioSourceVar;

        [SerializeField]
        [VariableProperty(typeof(FloatVariable), typeof(IntegerVariable), typeof(BooleanVariable))]
        protected Variable _inOutVar;

        public override void OnEnter()
        {
            if (_audioSourceVar == null || _inOutVar == null || _audioSourceVar.Value == null)
            {
                Debug.LogError("AudioSource or variable not set!");
                Continue();
                return;
            }

            var target = _audioSourceVar.Value;
            var floatVar = _inOutVar as FloatVariable;
            var boolVar = _inOutVar as BooleanVariable;
            var intVar = _inOutVar as IntegerVariable;

            switch (getOrSet)
            {
                case GetSet.Get:
                    switch (property)
                    {
                        case Property.Volume:
                            if (floatVar == null) { Debug.LogError("Type mismatch"); return; }
                            floatVar.Value = target.volume;
                            break;
                        // Остальные case...
                        default:
                            Debug.LogError($"Unsupported get property: {property}");
                            break;
                    }
                    break;

                case GetSet.Set:
                    switch (property)
                    {
                        case Property.Volume:
                            if (floatVar == null) { Debug.LogError("Type mismatch"); return; }
                            target.volume = floatVar.Value;
                            break;
                        // Остальные case...
                        default:
                            Debug.LogError($"Unsupported set property: {property}");
                            break;
                    }
                    break;
            }

            Continue();
        }
    }
}
Итоговые рекомендации:

Привести именование полей к стандарту (camelCase с _).

Добавить проверки на null и соответствие типов.

Улучшить обработку ошибок в switch.

Дополнить документацию примерами.

Оптимизировать простые методы (например, HasReference).
1. Именование
✅ Класс BaseUnaryMathCommand — имя соответствует конвенции PascalCase и чётко отражает назначение.

❗ Поля inValue, outValue — нарушают конвенцию именования protected полей (должны быть _inValue, _outValue).
Рекомендация:

csharp
[SerializeField]
protected FloatData _inValue;

[SerializeField]
protected FloatData _outValue;
2. Документация
❗ XML-комментарий класса слишком краткий.
Улучшение:

csharp
/// <summary>
/// Абстрактный базовый класс для математических команд с одним входным значением.
/// Наследуйте этот класс для реализации операций типа Sin, Cos, Abs и т.д.
/// </summary>
❗ Не хватает примеров использования.
Добавить:

csharp
/// <example>
/// <code>
/// // Пример реализации команды Abs:
/// public override void OnEnter() 
/// {
///     _outValue.Value = Mathf.Abs(_inValue.Value);
///     Continue();
/// }
/// </code>
/// </example>
3. Безопасность и проверки
❗ Отсутствует проверка на null в методах GetSummary() и HasReference().
Исправление:

csharp
public override string GetSummary()
{
    string inStr = _inValue?.floatRef?.Key ?? _inValue.Value.ToString();
    string outStr = _outValue?.floatRef?.Key ?? _outValue.Value.ToString();
    return $"in: {inStr}, out: {outStr}";
}

public override bool HasReference(Variable variable)
{
    return variable == _inValue?.floatRef || 
           variable == _outValue?.floatRef;
}
4. Структура кода
✅ Абстрактный класс — корректное использование для базовой логики.

✅ Атрибуты [AddComponentMenu("")] и [Tooltip] используются правильно.

❗ Метод GetButtonColor() — хардкод цвета. Лучше вынести в константу.
Улучшение:

csharp
private static readonly Color32 ButtonColor = new Color32(235, 191, 217, 255);

public override Color GetButtonColor() => ButtonColor;
5. Прочие замечания
✅ Сериализуемые поля помечены атрибутом [SerializeField].

❗ Метод GetSummary() можно оптимизировать с помощью интерполяции строк:

csharp
public override string GetSummary()
    => $"in: {_inValue?.floatRef?.Key ?? _inValue.Value.ToString()}, " +
       $"out: {_outValue?.floatRef?.Key ?? _outValue.Value.ToString()}";
Исправленная версия кода
csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Абстрактный базовый класс для математических команд с одним входным значением.
    /// Наследуйте этот класс для реализации операций типа Sin, Cos, Abs и т.д.
    /// </summary>
    /// <example>
    /// <code>
    /// // Пример реализации команды Abs:
    /// public override void OnEnter() 
    /// {
    ///     _outValue.Value = Mathf.Abs(_inValue.Value);
    ///     Continue();
    /// }
    /// </code>
    /// </example>
    [AddComponentMenu("")]
    public abstract class BaseUnaryMathCommand : Command
    {
        private static readonly Color32 ButtonColor = new Color32(235, 191, 217, 255);

        [Tooltip("Value to be passed in to the function.")]
        [SerializeField]
        protected FloatData _inValue;

        [Tooltip("Where the result of the function is stored.")]
        [SerializeField]
        protected FloatData _outValue;

        public override Color GetButtonColor() => ButtonColor;

        public override string GetSummary()
            => $"in: {_inValue?.floatRef?.Key ?? _inValue.Value.ToString()}, " +
               $"out: {_outValue?.floatRef?.Key ?? _outValue.Value.ToString()}";

        public override bool HasReference(Variable variable)
            => variable == _inValue?.floatRef || 
               variable == _outValue?.floatRef;
    }
}
Итоговые рекомендации
Исправьте именование полей на _camelCase.

Добавьте полную документацию с примерами.

Оптимизируйте методы через null-проверки (?.) и интерполяцию строк.

Вынесите константы (например, цвет кнопки).

Код соответствует стандартам, но эти изменения повысят его надежность и читаемость.
1. Именование
✅ Класс Break - имя соответствует PascalCase и точно отражает назначение.

✅ Методы и переменные (OnEnter, GetButtonColor, loopingCond) - соблюдают camelCase.

❗ Параметр i в цикле - лучше использовать более описательное имя, например commandIndex.

2. Документация
✅ XML-комментарий класса четко описывает функционал.

❗ Не хватает примеров использования.
Рекомендация:

csharp
/// <example>
/// <code>
/// // Пример использования в цикле While:
/// int i = 0;
/// while (i < 10)
/// {
///     if (i == 5) 
///     {
///         // Прерывание цикла при i == 5
///         break;
///     }
///     i++;
/// }
/// </code>
/// </example>
3. Структура кода
✅ Логика поиска цикла - корректная реверсивная итерация по командам.

❗ Хардкод цвета кнопки - лучше вынести в константу.
Улучшение:

csharp
private static readonly Color32 BreakButtonColor = new Color32(253, 253, 150, 255);

public override Color GetButtonColor() => BreakButtonColor;
4. Обработка ошибок
✅ Проверка на null для loopingCond присутствует.

❗ Логирование ошибки можно улучшить:

csharp
Debug.LogError($"Break command used outside of loop at {GetLocationIdentifier()}");
5. Производительность
✅ Цикл с ранним выходом (break) оптимизирован.

❗ Приведение типов as Condition - нормально, но можно добавить проверку:

csharp
if (ParentBlock.CommandList[i] is Condition cond && cond.IsLooping)
6. Стиль
❗ Регион #region Public members - избыточен для небольшого класса.

✅ Атрибуты [CommandInfo] и [AddComponentMenu] используются правильно.

Улучшенная версия кода
csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Force a loop to terminate immediately.
    /// </summary>
    /// <example>
    /// <code>
    /// // Пример использования в цикле While:
    /// int i = 0;
    /// while (i < 10)
    /// {
    ///     if (i == 5) 
    ///     {
    ///         break; // Прерывание цикла
    ///     }
    ///     i++;
    /// }
    /// </code>
    /// </example>
    [CommandInfo("Flow", 
                 "Break", 
                 "Force a loop to terminate immediately.")]
    [AddComponentMenu("")]
    public class Break : Command
    {
        private static readonly Color32 ButtonColor = new Color32(253, 253, 150, 255);

        public override void OnEnter()
        {
            Condition loopCondition = null;
            
            for (int commandIndex = CommandIndex - 1; commandIndex >= 0; commandIndex--)
            {
                if (ParentBlock.CommandList[commandIndex] is Condition cond && cond.IsLooping)
                {
                    loopCondition = cond;
                    break;
                }
            }

            if (loopCondition == null)
            {
                Debug.LogError($"Break command used outside of loop at {GetLocationIdentifier()}");
                Continue();
            }
            else
            {
                loopCondition.MoveToEnd();
            }
        }

        public override Color GetButtonColor() => ButtonColor;
    }
}
Итоговые рекомендации
Добавьте пример использования в XML-документацию.

Вынесите цвет кнопки в константу.

Улучшите именование переменных в цикле.

Оптимизируйте приведение типов через is + паттерн-матчинг.

Упростите структуру (уберите избыточный регион).

Корректность логики не вызывает нареканий - команда выполняет свою задачу по прерыванию циклов.
1. Именование
✅ Классы и enum (Call, CallMode) - соответствуют PascalCase.

✅ Параметры (targetFlowchart, startIndex) - корректный camelCase.

❗ Поле startLabel - лучше использовать более явное имя, например _startLabel для private полей.

❗ Локальная переменная onComplete - можно уточнить, например completionCallback.

2. Документация
✅ XML-комментарии для enum CallMode отличные.

❗ Не хватает примеров для класса Call.
Рекомендация:

csharp
/// <example>
/// <code>
/// // Пример вызова блока с ожиданием завершения:
/// targetBlock = MyBlock;
/// callMode = CallMode.WaitUntilFinished;
/// </code>
/// </example>
3. Структура кода
✅ Логика вызова блоков - четко разделена на случаи.

❗ Длинный метод OnEnter() (45 строк) - можно выделить логику в отдельные методы:

csharp
private void HandleSameFlowchartExecution(Action onComplete, int index)
{
    if (callMode == CallMode.StopThenCall) StopParentBlock();
    StartCoroutine(targetBlock.Execute(index, onComplete));
}
✅ Интерфейс IBlockCaller - хорошее использование контрактов.

4. Обработка ошибок
✅ Проверка на null для targetBlock присутствует.

✅ Предупреждение при повторном вызове блока.

❗ Не обрабатывается случай неверного startIndex.
Улучшение:

csharp
if (index < 0 || index >= targetBlock.CommandList.Count)
{
    Debug.LogError($"Invalid start index: {index}");
    return;
}
5. Производительность
✅ Кэширование компонентов - GetFlowchart() вызывается один раз.

❗ Создание делегата в WaitUntilFinished - можно вынести в поле при частых вызовах.

6. Стиль
❗ Регион #region Public members - избыточен (все методы public).

✅ Атрибуты [CommandInfo], [Tooltip] используются правильно.

❗ Хардкод цвета - лучше вынести в константу.

Улучшенная версия кода
csharp
using UnityEngine;
using System;
using System.Collections.Generic;

namespace Fungus
{
    /// <summary>
    /// Execute another block in the same Flowchart as the command, or in a different Flowchart.
    /// </summary>
    /// <example>
    /// <code>
    /// // Пример вызова блока с ожиданием завершения:
    /// targetBlock = MyBlock;
    /// callMode = CallMode.WaitUntilFinished;
    /// </code>
    /// </example>
    [CommandInfo("Flow", "Call", "Execute another block")]
    [AddComponentMenu("")]
    public class Call : Command, IBlockCaller
    {
        private const byte ButtonColorR = 235;
        private const byte ButtonColorG = 191;
        private const byte ButtonColorB = 217;
        
        [Tooltip("Flowchart containing the block to execute. Leave empty for current Flowchart.")]
        [SerializeField] private Flowchart _targetFlowchart;

        [Tooltip("Block to start executing")]
        [SerializeField] private Block _targetBlock;

        [Tooltip("Execution start label (prioritized over startIndex)")]
        [SerializeField] private StringData _startLabel = new StringData();

        [Tooltip("Command index to start executing")]
        [SerializeField] private int _startIndex;
    
        [Tooltip("Call behavior mode")]
        [SerializeField] private CallMode _callMode;

        public override void OnEnter()
        {
            if (_targetBlock == null)
            {
                CompleteExecution();
                return;
            }

            if (IsSelfCall(ParentBlock, _targetBlock))
            {
                Continue(0);
                return;
            }

            if (_targetBlock.IsExecuting())
            {
                Debug.LogWarning($"{_targetBlock.BlockName} is already running");
                CompleteExecution();
                return;
            }

            ExecuteTargetBlock(CreateCompletionCallback());
        }

        private bool IsSelfCall(Block parent, Block target) 
            => parent != null && parent.Equals(target);

        private Action CreateCompletionCallback() 
            => _callMode == CallMode.WaitUntilFinished ? (Action)Continue : null;

        private void ExecuteTargetBlock(Action onComplete)
        {
            int startIndex = CalculateStartIndex();
            
            if (_targetFlowchart == null || _targetFlowchart.Equals(GetFlowchart()))
            {
                ExecuteLocalBlock(startIndex, onComplete);
            }
            else
            {
                ExecuteExternalBlock(startIndex, onComplete);
            }

            CompleteExecution();
        }

        private int CalculateStartIndex()
        {
            if (!string.IsNullOrEmpty(_startLabel.Value))
            {
                int labelIndex = _targetBlock.GetLabelIndex(_startLabel.Value);
                if (labelIndex != -1) return labelIndex;
            }
            return _startIndex;
        }

        private void ExecuteLocalBlock(int index, Action onComplete)
        {
            if (_callMode == CallMode.StopThenCall) StopParentBlock();
            StartCoroutine(_targetBlock.Execute(index, onComplete));
        }

        private void ExecuteExternalBlock(int index, Action onComplete)
        {
            if (_callMode == CallMode.StopThenCall) StopParentBlock();
            _targetFlowchart.ExecuteBlock(_targetBlock, index, onComplete);
        }

        private void CompleteExecution()
        {
            if (_callMode == CallMode.Stop) StopParentBlock();
            else if (_callMode == CallMode.Continue) Continue();
        }

        // ... остальные методы без изменений ...
    }
}
Ключевые улучшения
Разделение OnEnter() на логические методы

Улучшенная обработка ошибок для индексов

Константы для цвета кнопки

Более четкие имена переменных

Документация с примером

Оптимизация создания делегатов

Код стал более:

Читаемым (разделение на методы)

Надежным (доп. проверки)

Поддерживаемым (ясные названия)
1. Именование
✅ Класс CallMethod - имя соответствует PascalCase и точно отражает функционал.

❗ Поле targetObject - нарушает конвенцию именования protected полей (должно быть _targetObject).

❗ Поле methodName - аналогично, лучше _methodName.

✅ Метод CallTheMethod() - хорошее название, но можно уточнить, например SendTargetMessage().

2. Документация
✅ XML-комментарий класса хорошо объясняет назначение.

❗ Не хватает примеров использования.
Рекомендация:

csharp
/// <example>
/// <code>
/// // Пример вызова метода "OnInteraction" на объекте Player:
/// targetObject = Player;
/// methodName = "OnInteraction";
/// delay = 1.5f;
/// </code>
/// </example>
3. Структура кода
✅ Логика вызова метода четко разделена на случаи с задержкой и без.

❗ Использование Invoke с строковым параметром - устаревший подход.
Лучше использовать:

csharp
Invoke(nameof(CallTheMethod), delay);
✅ Проверки в GetSummary() корректны.

4. Обработка ошибок
✅ Проверка на null и пустую строку в OnEnter().

❗ Нет обработки исключений для SendMessage.
Можно добавить:

csharp
try {
    targetObject.SendMessage(...);
}
catch (Exception e) {
    Debug.LogError($"Method call failed: {e.Message}");
}
5. Производительность
✅ Mathf.Approximately для сравнения float - правильный выбор.

❗ Строковый параметр в Invoke - небольшой оверхед (лучше использовать nameof).

6. Стиль
❗ Регион #region Public members - избыточен для небольшого класса.

✅ Атрибуты [CommandInfo] и [Tooltip] используются правильно.

❗ Хардкод цвета - лучше вынести в константу.

Улучшенная версия кода
csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Calls a named method on a GameObject using the GameObject.SendMessage() system.
    /// </summary>
    /// <example>
    /// <code>
    /// // Пример вызова метода "OnInteraction":
    /// targetObject = Player;
    /// methodName = "OnInteraction";
    /// delay = 1.5f;
    /// </code>
    /// </example>
    [CommandInfo("Scripting", "Call Method", "Calls a method via SendMessage")]
    [AddComponentMenu("")]
    public class CallMethod : Command
    {
        private const byte ButtonColorR = 235;
        private const byte ButtonColorG = 191;
        private const byte ButtonColorB = 217;

        [Tooltip("Target GameObject containing the method")]
        [SerializeField] protected GameObject _targetObject;

        [Tooltip("Name of the method to call")]
        [SerializeField] protected string _methodName = "";

        [Tooltip("Call delay in seconds")]
        [SerializeField] protected float _delay;

        protected virtual void SendTargetMessage()
        {
            if (_targetObject == null) return;

            try 
            {
                _targetObject.SendMessage(_methodName, 
                    SendMessageOptions.DontRequireReceiver);
            }
            catch (Exception e)
            {
                Debug.LogError($"Method '{_methodName}' call failed: {e.Message}");
            }
        }

        public override void OnEnter()
        {
            if (IsInvalidCall()) 
            {
                Continue();
                return;
            }

            if (Mathf.Approximately(_delay, 0f))
            {
                SendTargetMessage();
            }
            else
            {
                Invoke(nameof(SendTargetMessage), _delay);
            }

            Continue();
        }

        private bool IsInvalidCall() 
            => _targetObject == null || string.IsNullOrEmpty(_methodName);

        public override string GetSummary()
        {
            if (_targetObject == null)
                return "Error: No target GameObject specified";

            if (string.IsNullOrEmpty(_methodName))
                return "Error: No method name specified";

            return $"{_targetObject.name} : {_methodName}";
        }

        public override Color GetButtonColor() 
            => new Color32(ButtonColorR, ButtonColorG, ButtonColorB, 255);
    }
}
Ключевые улучшения
Безопасность: Добавлена обработка исключений для SendMessage

Читаемость:

Переименованы поля с _ префиксом

Выделена проверка IsInvalidCall()

Современный C#: Использование nameof вместо строки

Документация: Добавлен пример использования

Оптимизация: Константы для цвета кнопки

Код стал более:

Надежным (обработка ошибок)

Читаемым (ясные названия)

Поддерживаемым (документация)
1. Именование
✅ Класс Clamp - имя соответствует PascalCase и точно отражает функционал

❗ Поля lower, upper, value, outValue - нарушают конвенцию именования protected полей (должны быть _lower, _upper и т.д.)

✅ Enum Mode - хорошие понятные значения

2. Документация
✅ Базовый XML-комментарий класса имеется

❗ Не хватает примеров использования и описания режимов
Рекомендация:

csharp
/// <example>
/// <code>
/// // Пример ограничения значения от 0 до 10:
/// lower = 0;
/// upper = 10;
/// value = 12;
/// mode = Mode.Clamp; // Результат: 10
/// 
/// // Пример работы в режиме PingPong:
/// mode = Mode.PingPong;
/// value = 13; // Результат: 7 (10 - (13 - 10))
/// </code>
/// </example>
❗ Закомментированный Tooltip - нужно либо удалить, либо раскомментировать

3. Структура кода
✅ Логика ограничения значений четко разделена по режимам

❗ Дублирование вычислений в Repeat/PingPong - можно вынести (u - l) в переменную

✅ Проверки в GetSummary() корректны

4. Обработка ошибок
✅ Проверка на null в GetSummary()

❗ Нет проверки на lower > upper
Рекомендация:

csharp
if (_lower.Value > _upper.Value)
{
    Debug.LogError("Lower bound cannot be greater than upper bound");
    Continue();
    return;
}
5. Производительность
✅ Локальные переменные для значений предотвращают многократные вызовы .Value

❗ Вычисление (u - l) дважды в Repeat/PingPong - можно оптимизировать

6. Стиль
❗ Пустой default case - лучше добавить обработку ошибки

✅ Атрибуты [CommandInfo] используются правильно

❗ Хардкод цвета - лучше вынести в константу

Улучшенная версия кода
csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Command to contain a value between bounds with different wrapping modes
    /// </summary>
    /// <example>
    /// <code>
    /// // Пример ограничения значения:
    /// lower = 0;
    /// upper = 10;
    /// value = 12;
    /// mode = Mode.Clamp; // Результат: 10
    /// </code>
    /// </example>
    [CommandInfo("Math", "Clamp", "Clamps a value between bounds")]
    [AddComponentMenu("")]
    public class Clamp : Command
    {
        private const byte ButtonColorR = 235;
        private const byte ButtonColorG = 191;
        private const byte ButtonColorB = 217;

        public enum Mode { Clamp, Repeat, PingPong }
        
        [SerializeField] protected Mode _mode = Mode.Clamp;
        [SerializeField] protected FloatData _lower, _upper, _value;
        
        [Tooltip("Output value (don't use same var as input in PingPong mode)")]
        [SerializeField] protected FloatData _outValue;

        public override void OnEnter()
        {
            if (_lower.Value > _upper.Value)
            {
                Debug.LogError("Invalid bounds: lower > upper");
                Continue();
                return;
            }

            float l = _lower.Value;
            float u = _upper.Value;
            float range = u - l;
            float v = _value.Value;

            switch (_mode)
            {
                case Mode.Clamp:
                    _outValue.Value = Mathf.Clamp(v, l, u);
                    break;
                    
                case Mode.Repeat:
                    _outValue.Value = Mathf.Repeat(v - l, range) + l;
                    break;
                    
                case Mode.PingPong:
                    _outValue.Value = Mathf.PingPong(v - l, range) + l;
                    break;
                    
                default:
                    Debug.LogError($"Unsupported mode: {_mode}");
                    break;
            }

            Continue();
        }

        public override string GetSummary()
        {
            if (_outValue.floatRef == null)
                return "Error: No output variable";

            return $"{_outValue.floatRef.Key} = {_mode}";
        }

        public override bool HasReference(Variable variable)
            => _lower.floatRef == variable || 
               _upper.floatRef == variable || 
               _value.floatRef == variable || 
               _outValue.floatRef == variable;

        public override Color GetButtonColor() 
            => new Color32(ButtonColorR, ButtonColorG, ButtonColorB, 255);
    }
}
Ключевые улучшения
Безопасность: Добавлена проверка на корректность границ

Оптимизация: Вычисление range вынесено в переменную

Читаемость:

Переименованы поля с _ префиксом

Улучшено форматирование switch-case

Документация: Добавлен пример использования

Обработка ошибок: Добавлен default case с сообщением

Код стал более:

Надежным (проверки ошибок)

Эффективным (оптимизация вычислений)

Поддерживаемым (ясная структура)
1. Именование
✅ Класс ClearMenu - имя соответствует PascalCase и точно отражает функционал

❗ Поле menuDialog - нарушает конвенцию именования protected полей (должно быть _menuDialog)

✅ Метод Clear() - хорошее название, ясно отражает действие

2. Документация
✅ Базовый XML-комментарий класса имеется

❗ Не хватает примеров использования
Рекомендация:

csharp
/// <example>
/// <code>
/// // Пример очистки меню:
/// menuDialog = MyMenuDialog;
/// // После выполнения команды все опции меню будут удалены
/// </code>
/// </example>
3. Структура кода
✅ Логика простая и понятная - один вызов метода Clear()

✅ Проверка на null в GetSummary()

❗ Регион #region Public members избыточен для такого простого класса

4. Обработка ошибок
✅ Проверка на null в GetSummary()

❗ Нет проверки на null в OnEnter()
Рекомендация:

csharp
if (_menuDialog == null)
{
    Debug.LogError("MenuDialog reference is null");
    Continue();
    return;
}
5. Стиль
✅ Атрибуты [CommandInfo] и [Tooltip] используются правильно

❗ Хардкод цвета - лучше вынести в константу

❗ Пустая строка перед #region - лишний отступ

Улучшенная версия кода
csharp
using UnityEngine;

namespace Fungus
{
    /// <summary>
    /// Clears the options from a menu dialogue.
    /// </summary>
    /// <example>
    /// <code>
    /// // Пример очистки меню:
    /// menuDialog = MyMenuDialog;
    /// // После выполнения команды все опции меню будут удалены
    /// </code>
    /// </example>
    [CommandInfo("Narrative", "Clear Menu", "Clears menu options")]
    public class ClearMenu : Command 
    {
        private const byte ButtonColorR = 184;
        private const byte ButtonColorG = 210;
        private const byte ButtonColorB = 235;

        [Tooltip("Menu Dialog to clear")]
        [SerializeField] protected MenuDialog _menuDialog;

        public override void OnEnter()
        {
            if (_menuDialog == null)
            {
                Debug.LogError("MenuDialog reference is null", this);
                Continue();
                return;
            }

            _menuDialog.Clear();
            Continue();
        }

        public override string GetSummary()
        {
            return _menuDialog == null 
                ? "Error: No menu dialog selected" 
                : _menuDialog.name;
        }
        
        public override Color GetButtonColor() 
            => new Color32(ButtonColorR, ButtonColorG, ButtonColorB, 255);
    }
}
Ключевые улучшения
Безопасность: Добавлена проверка на null в OnEnter()

Читаемость:

Переименовано поле в _menuDialog

Упрощена структура (удален регион)

Документация: Добавлен пример использования

Стиль:

Вынесены константы цвета

Улучшено форматирование GetSummary()

Код стал более:

Надежным (дополнительные проверки)

Читаемым (ясные названия)

Поддерживаемым (документация с примером)

Дополнительные рекомендации
Рассмотрите возможность добавления события после очистки меню

Можно добавить опциональный параметр для выборочной очистки определенных опций

Для сложных сценариев можно добавить callback на завершение очистки